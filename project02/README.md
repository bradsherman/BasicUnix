Project 02: Distributed Computing
=================================

1. To implement hulk, we began by first parsing command line arguments with getopts. Next, we read the list of hashes from a file into a python list using a list comprehension. Then, we iterate over all possible strings up to LENGTH using itertools.product, adding a prefix if necesary. For each of the possible strings, we compute the checksum and if the checksum is in the hashes list, we print the corresponding password to standard out. We tested that hulk works properly by outputting all the password strings it generated and ran it for small LENGTH arguments against the hash list to see that the output looked reasonable.

2. For fury, it first initalizes a work queue and a log. Then, if there is a journal file, we load it into a dictionary (so that in case of a crash, we don't repeat tasks we have already run) followed by creating the first task (assuming it wasn't in the journal) which is to look at all passwords up to length five using the hulk script. We split up the work by making sure every task only needs to compute passwords of length five. We did this by telling hulk to append a prefix to every string of length five. We had an individual task for every prefix to length 3. This means in total we were searching strings up to length eight, although no one hulk task was required to compute more than all strings of length 5. When each response was recieved, it was written to a file named journal.json. This allowed us to keep track of what was attempted, so in the case of a failure we didn't repeat any tasks that we already had a response to. This was also the file we took all the final passwords from. We tested fury by first running it using a local worker for a small number of passwords and checking that the journal contained what we expected to see from hulk. 

3. A more complex alphabet would be harder to brute force than longer passwords. If we have a password string of length 3 and have two characters to choose from for password letter, we would have 2 * 2 * 2 = 8 possible passwords to try. If we made the password one character longer, we would have 2 * 2 * 2 * 2 = 16 passwords. If we instead added a possibility for each letter of the password, we would have 3 * 3 * 3 = 27 cominations to try. It's easy to see that more options for each letter make more of a difference than a longer string.
